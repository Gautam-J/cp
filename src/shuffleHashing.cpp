/* CF - 1000 */
/*
A. Shuffle Hashing
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
Polycarp has built his own web service. Being a modern web service it includes login feature. And that always implies password security problems.

Polycarp decided to store the hash of the password, generated by the following algorithm:

take the password ??
p
, consisting of lowercase Latin letters, and shuffle the letters randomly in it to obtain ???
p
?
 (???
p
?
 can still be equal to ??
p
);
generate two random strings, consisting of lowercase Latin letters, ??1
s
1
 and ??2
s
2
 (any of these strings can be empty);
the resulting hash ?=??1+???+??2
h
=
s
1
+
p
?
+
s
2
, where addition is string concatenation.
For example, let the password ??=
p
=
 "abacaba". Then ???
p
?
 can be equal to "aabcaab". Random strings ??1=
s
1
=
 "zyx" and ??2=
s
2
=
 "kjh". Then ?=
h
=
 "zyxaabcaabkjh".

Note that no letters could be deleted or added to ??
p
 to obtain ???
p
?
, only the order could be changed.

Now Polycarp asks you to help him to implement the password check module. Given the password ??
p
 and the hash ?
h
, check that ?
h
 can be the hash for the password ??
p
.

Your program should answer ??
t
 independent test cases.

Input
The first line contains one integer ??
t
 (1²??²100
1
²
t
²
100
) Ñ the number of test cases.

The first line of each test case contains a non-empty string ??
p
, consisting of lowercase Latin letters. The length of ??
p
 does not exceed 100
100
.

The second line of each test case contains a non-empty string ?
h
, consisting of lowercase Latin letters. The length of ?
h
 does not exceed 100
100
.

Output
For each test case print the answer to it Ñ "YES" if the given hash ?
h
 could be obtained from the given password ??
p
 or "NO" otherwise.

Example
inputCopy
5
abacaba
zyxaabcaabkjh
onetwothree
threetwoone
one
zzonneyy
one
none
twenty
ten
outputCopy
YES
YES
NO
YES
NO
Note
The first test case is explained in the statement.

In the second test case both ??1
s
1
 and ??2
s
2
 are empty and ???=
p
?
=
 "threetwoone" is ??
p
 shuffled.

In the third test case the hash could not be obtained from the password.

In the fourth test case ??1=
s
1
=
 "n", ??2
s
2
 is empty and ???=
p
?
=
 "one" is ??
p
 shuffled (even thought it stayed the same).

In the fifth test case the hash could not be obtained from the password.
*/

/* Can also use a brute force method that runs in O(n^3 log n) time. */

/* Time Complexity: O(n) */
/* Space Complexity: O(1) */

#include <bits/stdc++.h>
using namespace std;

void dbg_out() { cerr << endl; }
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

template<typename T> T gcd(T a, T b) { return ( b ? __gcd(a, b) : a); }
template<typename T> T lcm(T a, T b) { return (a * (b / gcd(a, b))); }

#define forn(i, n) for (int i = 0; i < n; i++)
#define fore(i, l, r) for (int i = (int)l; i <= (int)r; i++)
#define trav(i, a) for (auto& i : a)
#define all(a) a.begin(), a.end()
#define sz(x) (int)(x).size()
#define pb push_back
#define SHUF(v) shuffle(all(v), mt_rand)
#define umap unordered_map
#define uset unordered_set
#define imax INT_MAX
#define imin INT_MIN

#ifdef _GLIBCXX_DEBUG
#define debug(...) cerr << "[DEBUG]: [" << #__VA_ARGS__ << "]:", dbg_out(__VA_ARGS__)
#else
#define debug(...)
#endif

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef vector<int> vi;
typedef vector< vi > vvi;
typedef vector< pi > vpi;

// mt19937_64 for 64 bit random numbers
mt19937 mt_rand(chrono::high_resolution_clock::now().time_since_epoch().count());

const char nl = '\n';
const ld PI = acos(-1.0);

bool solve(string& p, string& h) {
    vi cntp(26);

    // calculate frequency of letters in password
    forn(i, sz(p))
        cntp[p[i] - 'a']++;

    // calculate frequency of letters in hash
    forn(i, sz(h)) {
        vi cnth(26);
        for (int j = i; j < sz(h); j++) {
            cnth[h[j] - 'a']++;

            // if frequencies match, password found as substring in hash
            if (cntp == cnth)
                return true;
        }
    }
    return false;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;

    string p, h;
    while (t--) {
        cin >> p >> h;
        cout << (solve(p, h) ? "YES" : "NO") << nl;
    }

#ifdef _GLIBCXX_DEBUG
    cerr << endl << "finished in " << clock() * 1.0 / CLOCKS_PER_SEC << " sec" << endl;
#endif

    return 0;
}
